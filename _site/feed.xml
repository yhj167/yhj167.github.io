<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Yinhj Blog</title>
    <description>关于后端与架构、分布式与大数据 | 殷华杰，Web &amp; 后端开发，分布式架构设计 | 这里是 @Yinhj殷华杰 的个人博客，与你一起发现更大的世界。</description>
    <link>http://yhj167.github.io/</link>
    <atom:link href="http://yhj167.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 22 Oct 2016 00:34:46 +0800</pubDate>
    <lastBuildDate>Sat, 22 Oct 2016 00:34:46 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>[操作系统篇]FAT文件系统原理分析</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;参考链接&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.sjhf.net/pdf/fat.pdf&quot;&gt;《FAT文件系统原理》&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 21 Oct 2016 04:00:00 +0800</pubDate>
        <link>http://yhj167.github.io/2016/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AF%87-FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</link>
        <guid isPermaLink="true">http://yhj167.github.io/2016/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AF%87-FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</guid>
        
        <category>操作系统</category>
        
        <category>文件系统</category>
        
        
      </item>
    
      <item>
        <title>块文件系统BUG引起的系统复位问题归零报告</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;故障现象&lt;/h3&gt;

&lt;p&gt;着陆时，MCU收集MFL数据并转发给VCM，由VCM存储到IDR记录卡。在MCU开始发送MFL数据9秒左右时，VCM复位。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;故障定位&lt;/h3&gt;

&lt;p&gt;测试发现，通过MCU端手动向双口长时间地周期（2个tick）写MFL数据，必然会导致VCM复位，有时候复位前会打印program和data access错误，有时候直接复位。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;分析可能出现的几种复位方式：&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;应用监控的任务挂起，引起的手动开门狗复位；&lt;/li&gt;
  &lt;li&gt;应用执行了非法指令、地址寻址错误、除数为0等，导致CPU死机无法喂狗，引起开门狗复位；&lt;/li&gt;
  &lt;li&gt;应用中断异常，导致引起CPU热复位。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;测试1：在VCM监控任务中，将任务挂起手动停止喂狗功能注释掉。&lt;/p&gt;

    &lt;p&gt;结果：VCM还是会出现复位，排除第1种复位。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;测试2：在VCM应用中禁掉看门狗。&lt;/p&gt;

    &lt;p&gt;结果：VCM有时还是会复位，有时会死机。说明VCM既会热复位，又会看门狗复位。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们知道vxworks5.5的没有用户态，用户没有自己的地址空间，非常不安全。所以应用访问异常的地址空间，很可能导致执行非法指令或寻址错误；甚至可能会导致中断异常而reboot。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;从数据流的过程分析可能引起复位的原因：&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;VCM和MCU的双口通信在数据量增大时是否可能访问数据越界。&lt;/li&gt;
  &lt;li&gt;VCM从双口取出数据存入本地缓存，写盘时从缓存中取数据，存取数据是否出错。&lt;/li&gt;
  &lt;li&gt;VCM写盘是否出错。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;测试3：在VCM应用中，屏蔽从双口读取MFL数据，以相同的数据流量仿真MFL数据，放入本地的MFL缓存中，VCM按原来的方式从缓存中取数据写盘。&lt;/p&gt;

    &lt;p&gt;结果：VCM还是会出现复位，排除MCU和VCM的双口通信问题，同时也将问题定位到了VCM端。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;测试4：打印存放MFL的当前扇区的有效字节数oddment(即偏移量)、缓存中取出的数据长度getlen、块数blocknum。取数据和写盘的代码如下：&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;blocknum = nbforng/512;	//nbforng为本地缓存中数据字节数&lt;/p&gt;

      &lt;p&gt;if(blocknum == 0) blocknum = 2;&lt;/p&gt;

      &lt;p&gt;ldrs_rawFsGetWrtBuf(fd, WRITE_LEN_MAX, &amp;amp;oddment);	//获取块文件系统写数据存放缓冲区&lt;/p&gt;

      &lt;p&gt;getlen = getdatafromrngbuf(rngid, semid, buf, (512*blocknum)-oddment);	//从缓存中取数据&lt;/p&gt;

      &lt;p&gt;… …&lt;/p&gt;

      &lt;p&gt;idrs_rawFsWrite(fd, dataidx, buf, getlen);		//写盘&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;结果：发现打印的当前扇区有效字节数oddment出现大于512的情况，然而一个扇区最大为512字节。所以，&lt;strong&gt;当oddment&amp;gt;512，且512&amp;lt;nbforng&amp;lt;1024时，会出现blocknum等于1，(512*blocknum)-oddment)&amp;lt;0的情况，导致取数据的长度&amp;lt;0&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;测试5：在串口中测试rngBufGet(MFL_ringid, buf, -1)，从MFL_ringid缓存中取-1长度的数据，会导致应用程序复位。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-4&quot;&gt;故障原因&lt;/h3&gt;

&lt;p&gt;VCM应用程序为了减少写盘次数，每次写盘都会凑512*blocknum字节的数据量，即凑完整的扇区来写盘。例如，缓存中数据量nbforng为1100字节，扇区偏移量oddment为124，则blocknum为2，算出实际写盘数据量为(512xblocknum)-oddment = 900字节，剩下的1100-900 = 200字节数据等下次写盘时再写。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一种异常情况，当环形缓存中数据量&amp;lt;512字节，即blocknum等于0时，取数据长度(512*blocknum)-oddment)为负值。应用对0值做了处理：&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;if(blocknum == 0) blocknum = 2;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;当环形缓存中数据量在512～1024字节范围，即blocknum等于1时，取数据长度(512*blocknum)-oddment)正常情况下为&amp;gt;=0，但实际oddment出现了&amp;gt;512的情况。因为当数据区通道数&amp;gt;1时，计算扇区偏移量oddment会加上14个字节的帧头，所以oddment的范围变为14～526了。&lt;/p&gt;

    &lt;p&gt;当oddment&amp;gt;512，且512&amp;lt;nbforng&amp;lt;1024，即blocknum等于1时，(512*blocknum)-oddment)&amp;lt;0，导致调用vxworks系统函数rngBufGet取数据时长度&amp;lt;0，CPU死机引起VCM应用程序复位。&lt;/p&gt;

    &lt;p&gt;那么，其他数据是否会引起同样的故障：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;LOG的数据区通道数为1且数据量小，oddment不会加14字节的帧头，oddment不会越界&amp;gt;512；&lt;/li&gt;
      &lt;li&gt;音视频正常数据量大，blocknum = nbforng/512，blocknum&amp;gt;2，而blocknum只有为1才会导致异常，所以基本不会引起异常；&lt;/li&gt;
      &lt;li&gt;电子战EW/武器BUS/飞参FPA/BM总线数据的正常数据量&amp;lt;512字节，blocknum为0，所以基本不会引起异常；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;测试6：同时，测试在vxworks6.8系统下，调用rngBufGet函数取负值长度的数据返回-1，但不会引起CPU死机。而10C使用的是vxworks6.8系统，并且没有采用这种凑512*blocknum字节数据量写盘的方式，所以10C不会出现这样的故障。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-5&quot;&gt;解决方案&lt;/h3&gt;

&lt;p&gt;块文件系统中判断逻辑，当数据区通道数&amp;gt;1时，写盘会增加14个字节，其中8个字节帧头，6个字节帧尾。而应用计算从本地缓存中可取数据量时，不包括这14字节（因为这是文件系统驱动中加的），所以为了留出14个字节，偏移量oddment计算时加上了14个字节：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;oddment = 14字节帧头帧尾 + 当前扇区实际偏移量oddment_actual;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;为了写扇区时凑完整的扇区，从缓存中取(blocknum*512)-oddment字节的数据，如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;//从缓存中取数据&lt;/p&gt;

  &lt;p&gt;getlen = getdatafromrngbuf(rngid, semid, buf, (blocknum*512)-oddment);&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因为扇区偏移量oddment并非实际偏移量，其范围为14～526，可能导致(blocknum*512)-oddment为负值。所以，计算oddment时，得出的结果后面加一句：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;*oddment = *oddment%512;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;使得扇区偏移量范围在0～512字节之间。&lt;/p&gt;

&lt;p&gt;例如：缓存中数据量nbforng为600字节，实际偏移量oddment_actual为500字节时，计算oddment ＝ (500+14)%512 = 2，blocknum = nbforng/512 = 1，(blocknum*512)-oddment = 510。从缓存中取510字节，剩下600-510=90字节下次再写。实际写盘数据量为510+14=524字节，从扇区实际偏移量oddment_actual为500开始写，刚好写满下个扇区。&lt;/p&gt;
</description>
        <pubDate>Sat, 15 Oct 2016 04:00:00 +0800</pubDate>
        <link>http://yhj167.github.io/2016/10/15/%E5%9D%97%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FBUG%E5%BC%95%E8%B5%B7%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%BD%8D%E9%97%AE%E9%A2%98%E5%BD%92%E9%9B%B6%E6%8A%A5%E5%91%8A/</link>
        <guid isPermaLink="true">http://yhj167.github.io/2016/10/15/%E5%9D%97%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FBUG%E5%BC%95%E8%B5%B7%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%BD%8D%E9%97%AE%E9%A2%98%E5%BD%92%E9%9B%B6%E6%8A%A5%E5%91%8A/</guid>
        
        <category>嵌入式</category>
        
        <category>文件系统</category>
        
        
      </item>
    
      <item>
        <title>基于UDP实现的可靠传输协议</title>
        <description>&lt;p&gt;UDP实现的可靠协议，基本都会对TCP的某一部分进行加强，另外一部分进行削弱。因为：
“实时性+可靠性+公平性” 三者不能同时保证，因此可以牺牲TCP的局部公平性来换取更好的实时性，或者更浪费点带宽，来实现更低的延迟。&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;参考资料&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/20292749&quot;&gt;QQ 为什么采用 UDP 协议，而不采用 TCP 协议实现&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 23 Sep 2016 04:30:00 +0800</pubDate>
        <link>http://yhj167.github.io/2016/09/23/%E5%9F%BA%E4%BA%8EUDP%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/</link>
        <guid isPermaLink="true">http://yhj167.github.io/2016/09/23/%E5%9F%BA%E4%BA%8EUDP%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/</guid>
        
        <category>UDP</category>
        
        <category>网络协议</category>
        
        
      </item>
    
      <item>
        <title>TCP粘包分析</title>
        <description>&lt;p&gt;这两天看csdn有一些关于socket粘包，socket缓冲区设置的问题，发现自己不是很清楚，所以查资料了解记录一下： 
一 .两个简单概念长连接与短连接：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;长连接
    Client方与Server方先建立通讯连接，连接建立后不断开， 然后再进行报文发送和接收。&lt;/li&gt;
  &lt;li&gt;短连接
    Client方与Server每进行一次报文收发交易时才进行通讯连接，交易完毕后立即断开连接。此种方式常用于一点对多点 
通讯，比如多个Client连接一个Server.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;二 .什么时候需要考虑粘包问题?
1:如果利用tcp每次发送数据，就与对方建立连接，然后双方发送完一段数据后，就关闭连接，这样就不会出现粘包问题（因为只有一种包结构,类似于http协议）。关闭连接主要要双方都发送close连接（参考tcp关闭协议）。如：A需要发送一段字符串给B，那么A与B建立连接，然后发送双方都默认好的协议字符如”hello give me sth abour yourself”，然后B收到报文后，就将缓冲区数据接收,然后关闭连接，这样粘包问题不用考虑到，因为大家都知道是发送一段字符。
2：如果发送数据无结构，如文件传输，这样发送方只管发送，接收方只管接收存储就ok，也不用考虑粘包
3：如果双方建立连接，需要在连接后一段时间内发送不同结构数据，如连接后，有好几种结构：
 1)”hello give me sth abour yourself” 
 2)”Don’t give me sth abour yourself” 
   那这样的话，如果发送方连续发送这个两个包出去，接收方一次接收可能会是”hello give me sth abour yourselfDon’t give me sth abour yourself” 这样接收方就傻了，到底是要干嘛？不知道，因为协议没有规定这么诡异的字符串，所以要处理把它分包，怎么分也需要双方组织一个比较好的包结构，所以一般可能会在头加一个数据长度之类的包，以确保接收。&lt;/p&gt;

&lt;p&gt;三 .粘包出现原因：在流传输中出现，UDP不会出现粘包，因为它有消息边界(参考Windows 网络编程)
1 发送端需要等缓冲区满才发送出去，造成粘包
2 接收方不及时接收缓冲区的包，造成多个包接收
解决办法：
为了避免粘包现象，可采取以下几种措施。一是对于发送方引起的粘包现象，用户可通过编程设置来避免，TCP提供了强制数据立即传送的操作指令push，TCP软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；二是对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、提高接收进程优先级等措施，使其及时接收数据，从而尽量避免出现粘包现象；三是由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。
以上提到的三种措施，都有其不足之处。第一种编程设置方法虽然可以避免发送方引起的粘包，但它关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用。第二种方法只能减少出现粘包的可能性，但并不能完全避免粘包，当发送频率较高时，或由于网络突发可能使某个时间段数据包到达接收方较快，接收方还是有可能来不及接收，从而导致粘包。第三种方法虽然避免了粘包，但应用程序的效率较低，对实时应用的场合不适合。
载自：http://blog.csdn.net/binghuazh/archive/2009/05/28/4222516.aspx&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;网络通讯的封包和拆包&lt;/h1&gt;
&lt;p&gt;对于基于TCP开发的通讯程序,有个很重要的问题需要解决,就是封包和拆包.
一.为什么基于TCP的通讯程序需要进行封包和拆包.
TCP是个”流”协议,所谓流,就是没有界限的一串数据.大家可以想想河里的流水,是连成一片的,其间是没有分界线的.但一般通讯程序开发是需要定义一个个相互独立的数据包的,比如用于登陆的数据包,用于注销的数据包.由于TCP”流”的特性以及网络状况,在进行数据传输时会出现以下几种情况.
假设我们连续调用两次send分别发送两段数据data1和data2,在接收端有以下几种接收情况(当然不止这几种情况,这里只列出了有代表性的情况).
A.先接收到data1,然后接收到data2.
B.先接收到data1的部分数据,然后接收到data1余下的部分以及data2的全部.
C.先接收到了data1的全部数据和data2的部分数据,然后接收到了data2的余下的数据.
D.一次性接收到了data1和data2的全部数据.
对于A这种情况正是我们需要的,不再做讨论.对于B,C,D的情况就是大家经常说的”粘包”,就需要我们把接收到的数据进行拆包,拆成一个个独立的数据包.为了拆包就必须在发送端进行封包.
另:对于UDP来说就不存在拆包的问题,因为UDP是个”数据包”协议,也就是两段数据间是有界限的,在接收端要么接收不到数据要么就是接收一个完整的一段数据,不会少接收也不会多接收.
二.为什么会出现B.C.D的情况.
“粘包”可发生在发送端也可发生在接收端.
1.由Nagle算法造成的发送端的粘包:Nagle算法是一种改善网络传输效率的算法.简单的说,当我们提交一段数据给TCP发送时,TCP并不立刻发送此段数据,而是等待一小段时间,看看在等待期间是否还有要发送的数据,若有则会一次把这两段数据发送出去.这是对Nagle算法一个简单的解释,详细的请看相关书籍.象C和D的情况就有可能是Nagle算法造成的.
2.接收端接收不及时造成的接收端粘包:TCP会把接收到的数据存在自己的缓冲区中,然后通知应用层取数据.当应用层由于某些原因不能及时的把TCP的数据取出来,就会造成TCP缓冲区中存放了几段数据.
三.怎样封包和拆包.
   最初遇到”粘包”的问题时,我是通过在两次send之间调用sleep来休眠一小段时间来解决.这个解决方法的缺点是显而易见的,使传输效率大大降低,而且也并不可靠.后来就是通过应答的方式来解决,尽管在大多数时候是可行的,但是不能解决象B的那种情况,而且采用应答方式增加了通讯量,加重了网络负荷. 再后来就是对数据包进行封包和拆包的操作.
    封包:
封包就是给一段数据加上包头,这样一来数据包就分为包头和包体两部分内容了(以后讲过滤非法包时封包会加入”包尾”内容).包头其实上是个大小固定的结构体,其中有个结构体成员变量表示包体的长度,这是个很重要的变量,其他的结构体成员可根据需要自己定义.根据包头长度固定以及包头中含有包体长度的变量就能正确的拆分出一个完整的数据包.
    对于拆包目前我最常用的是以下两种方式.
    1.动态缓冲区暂存方式.之所以说缓冲区是动态的是因为当需要缓冲的数据长度超出缓冲区的长度时会增大缓冲区长度.
    大概过程描述如下:
    A,为每一个连接动态分配一个缓冲区,同时把此缓冲区和SOCKET关联,常用的是通过结构体关联.
    B,当接收到数据时首先把此段数据存放在缓冲区中.
    C,判断缓存区中的数据长度是否够一个包头的长度,如不够,则不进行拆包操作.
    D,根据包头数据解析出里面代表包体长度的变量.
    E,判断缓存区中除包头外的数据长度是否够一个包体的长度,如不够,则不进行拆包操作.
    F,取出整个数据包.这里的”取”的意思是不光从缓冲区中拷贝出数据包,而且要把此数据包从缓存区中删除掉.删除的办法就是把此包后面的数据移动到缓冲区的起始地址.
这种方法有两个缺点.1.为每个连接动态分配一个缓冲区增大了内存的使用.2.有三个地方需要拷贝数据,一个地方是把数据存放在缓冲区,一个地方是把完整的数据包从缓冲区取出来,一个地方是把数据包从缓冲区中删除.第二种拆包的方法会解决和完善这些缺点.
前面提到过这种方法的缺点.下面给出一个改进办法, 即采用环形缓冲.但是这种改进方法还是不能解决第一个缺点以及第一个数据拷贝,只能解决第三个地方的数据拷贝(这个地方是拷贝数据最多的地方).第2种拆包方式会解决这两个问题.
环形缓冲实现方案是定义两个指针,分别指向有效数据的头和尾.在存放数据和删除数据时只是进行头尾指针的移动.
2.利用底层的缓冲区来进行拆包
由于TCP也维护了一个缓冲区,所以我们完全可以利用TCP的缓冲区来缓存我们的数据,这样一来就不需要为每一个连接分配一个缓冲区了.另一方面我们知道recv或者wsarecv都有一个参数,用来表示我们要接收多长长度的数据.利用这两个条件我们就可以对第一种方法进行优化.
     对于阻塞SOCKET来说,我们可以利用一个循环来接收包头长度的数据,然后解析出代表包体长度的那个变量,再用一个循环来接收包体长度的数据.
相关代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
char PackageHead[1024];
char PackageContext[1024*20];
int len;
PACKAGE_HEAD *pPackageHead;
while( m_bClose == false )
{
memset(PackageHead,0,sizeof(PACKAGE_HEAD));
len = m_TcpSock.ReceiveSize((char*)PackageHead,sizeof(PACKAGE_HEAD));
if( len == SOCKET_ERROR )
{
    break;
}
if(len == 0)
{
    break;
}
pPackageHead = (PACKAGE_HEAD *)PackageHead;
memset(PackageContext,0,sizeof(PackageContext));
if(pPackageHead-&amp;gt;nDataLen&amp;gt;0)
{
len = m_TcpSock.ReceiveSize((char*)PackageContext,pPackageHead-&amp;gt;nDataLen);
}
        }
m_TcpSock是一个封装了SOCKET的类的变量,其中的ReceiveSize用于接收一定长度的数据,直到接收了一定长度的数据或者网络出错才返回.

int winSocket::ReceiveSize( char* strData, int iLen )
{
if( strData == NULL )
return ERR_BADPARAM;
char *p = strData;
int len = iLen;
int ret = 0;
int returnlen = 0;
while( len &amp;gt; 0)
{
ret = recv( m_hSocket, p+(iLen-len), iLen-returnlen, 0 );
if ( ret == SOCKET_ERROR || ret == 0 )
{
return ret;
}
len -= ret;
returnlen += ret;
}
return returnlen;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于非阻塞的SOCKET,比如完成端口,我们可以提交接收包头长度的数据的请求,当 GetQueuedCompletionStatus返回时,我们判断接收的数据长度是否等于包头长度,若等于,则提交接收包体长度的数据的请求,若不等于则提交接收剩余数据的请求.当接收包体时,采用类似的方法.
载自： http://blog.csdn.net/fjcailei/archive/2009/06/17/4276463.aspx&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;这个问题产生于编程中遇到的几个问题：&lt;/h1&gt;
&lt;p&gt;几个问题：http://www.qqgb.com/Program/VC/VCJQ/Program_200509.html
1、使用TCP的Socket发送数据的时候，会出现发送出错，WSAEWOULDBLOCK，在TCP中不是会保证发送的数据能够安全的到达接收端的吗？也有窗口机制去防止发送速度过快，为什么还会出错呢？&lt;/p&gt;

&lt;p&gt;2、TCP协议，在使用Socket发送数据的时候，每次发送一个包，接收端是完整的接受到一个包还是怎么样？如果是每发一个包，就接受一个包，为什么还会出现粘包问题，具体是怎么运行的？&lt;/p&gt;

&lt;p&gt;3、关于Send，是不是只有在非阻塞状态下才会出现实际发送的比指定发送的小？在阻塞状态下会不会出现实际发送的比指定发送的小，就是说只能出现要么全发送，要么不发送？在非阻塞状态下，如果之发送了一些数据，要怎么处理，调用了Send函数后，发现返回值比指定的要小，具体要怎么做？&lt;/p&gt;

&lt;p&gt;4、最后一个问题，就是TCP/IP协议和Socket是什么关系？是指具体的实现上，Socket是TCP/IP的实现？那么为什么会出现使用TCP协议的Socket会发送出错（又回到第一个问题了，汗一个）&lt;/p&gt;

&lt;p&gt;实在是有点晕了，如果我的问题有不清楚的地方，或者分数有问题，欢迎指出，谢谢
这个问题第1个回答：
1 应该是你的缓冲区不够大, 
2 tcp是流,没有界限.也就所所谓的包. 
3 阻塞也会出现这种现象,出现后继续发送没发送出去的. 
4 tcp是协议,socket是一种接口,没必然联系.错误取决于你使用接口的问题,跟tcp没关系.
这个问题第2个回答：
1 应该是你的缓冲区不够大, 
2 tcp是流,没有界限.也就无所谓包. 
3 阻塞也会出现这种现象,出现后继续发送没发送出去的. 
4 tcp是协议,socket是一种接口,没必然联系.错误取决于你使用接口的问题,跟tcp没关系.
这个问题第3个回答：
1、应该不是缓冲区大小问题，我试过设置缓冲区大小，不过这里有个问题，就是就算我把缓冲区设置成几G，也返回成功，不过实际上怎么可能设置那么大、、、&lt;/p&gt;

&lt;p&gt;3、出现没发送完的时候要手动发送吧，有没有具体的代码实现？&lt;/p&gt;

&lt;p&gt;4、当选择TCP的Socket发送数据的时候，TCP中的窗口机制不是能防止发送速度过快的吗？为什么Socket在出现了WSAEWOULDBLOCK后没有处理？
这个问题第4个回答：
1.在使用非阻塞模式的情况下，如果系统发送缓冲区已满，并示及时发送到对端，就会产生该错误，继续重试即可。 
3.如果没有发完就继续发送后续部分即可。
这个问题第5个回答：
1、使用非阻塞模式时，如果当前操作不能立即完成则会返回失败，错误码是WSAEWOULDBLOCK，这是正常的，程序可以先执行其它任务，过一段时间后再重试该操作。 
2、发送与接收不是一一对应的，TCP会把各次发送的数据重新组合，可能合并也可能拆分，但发送次序是不变的。 
3、在各种情况下都要根据send的返回值来确定发送了多少数据，没有发送完就再接着发。 
4、socket是Windows提供网络编程接口，TCP/IP是网络传输协议，使用socket是可以使用多种协议，其中包括TCP/IP。
这个问题第6个回答：
发送的过程是：发送到缓冲区和从缓冲区发送到网络上
WSAEWOULDBLOCK和粘包都是出现在发送到缓冲区这个过程的。&lt;/p&gt;
</description>
        <pubDate>Wed, 21 Sep 2016 05:00:00 +0800</pubDate>
        <link>http://yhj167.github.io/2016/09/21/TCP%E7%B2%98%E5%8C%85%E6%8B%BC%E5%8C%85%E5%88%86%E6%9E%90/</link>
        <guid isPermaLink="true">http://yhj167.github.io/2016/09/21/TCP%E7%B2%98%E5%8C%85%E6%8B%BC%E5%8C%85%E5%88%86%E6%9E%90/</guid>
        
        <category>TCP</category>
        
        <category>网络协议</category>
        
        
      </item>
    
      <item>
        <title>Git常用命令(持续更新中)</title>
        <description>&lt;h3 id=&quot;git&quot;&gt;取得Git仓库&lt;/h3&gt;

&lt;p&gt;初始化一个版本仓库&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git init&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Clone远程版本库&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git clone https://github.com/yhj167/yhj167.github.io.git&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;添加远程版本库origin，语法为 git remote add [shortname] [url]&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git remote add origin https://github.com/yhj167/yhj167.github.io.git&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;查看远程仓库&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git remote -v&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section&quot;&gt;提交你的修改&lt;/h3&gt;

&lt;p&gt;添加当前修改的文件到暂存区&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git add .&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;添加所有修改的文件到暂存区&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git add -A&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;提交你的修改&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git commit –m “你的注释”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;推送你的更新到远程服务器,语法为 git push [远程名] [本地分支]:[远程分支]&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git push origin master&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;查看文件状态&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git status&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;从当前跟踪列表移除文件，并完全删除&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git rm readme.txt&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;仅在暂存区删除，保留文件在当前目录，不再跟踪&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git rm –cached readme.txt&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;重命名文件&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git mv reademe.txt readme&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;查看提交的历史记录&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git log&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;取消对文件的修改&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git checkout –- readme.txt&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;基本的分支管理&lt;/h3&gt;

&lt;p&gt;拉去远程仓库的数据，语法为 git fetch [remote-name]&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git fetch&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;fetch 会拉取最新的远程仓库数据，但不会自动到当前目录下，要自动合并&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git pull&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;查看远程仓库的信息&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git remote show origin&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;push所有分支&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git push&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;将本地主分支推到远程主分支&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git push origin master&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;将本地主分支推到远程(如无远程主分支则创建，客户端首次提交)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git push -u origin master&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;git-1&quot;&gt;Git回退到某个历史版本&lt;/h3&gt;

&lt;p&gt;1.使用Git log命令查看所有的历史版本，获取某个历史版本的id，假设查到历史版本的id。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git reset –hard id&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2.把修改推到远程服务器&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git push -f -u origin master&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;例子&lt;/h3&gt;

&lt;p&gt;首次创建git库&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;echo &quot;# hyaojia.github.io&quot; &amp;gt;&amp;gt; README.md
git init
git add README.md
git commit -m &quot;first commit&quot;
git remote add origin https://github.com/hyaojia/hyaojia.github.io.git
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://xbc.me/git-commands/&quot;&gt;参考资料&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 12 Sep 2016 04:10:00 +0800</pubDate>
        <link>http://yhj167.github.io/2016/09/12/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4(%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD)/</link>
        <guid isPermaLink="true">http://yhj167.github.io/2016/09/12/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4(%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD)/</guid>
        
        <category>git</category>
        
        <category>常用命令</category>
        
        
      </item>
    
      <item>
        <title>OSX命令(持续更新中)</title>
        <description>&lt;p&gt;在mac os下，如何通过命令行来下载网络文件？如果你没有安装或wget命令，那么可以使用curl工具来达到我们的目的。&lt;/p&gt;

&lt;h3 id=&quot;curl&quot;&gt;curl命令参数：&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;curl ‘url地址’&lt;/p&gt;

  &lt;p&gt;curl [选项] ‘url地址’&lt;/p&gt;

  &lt;p&gt;curl -O ‘url’&lt;/p&gt;

  &lt;p&gt;curl -L -O ‘url’&lt;/p&gt;

  &lt;p&gt;curl -o output.file.name.here ‘url-here’&lt;/p&gt;

  &lt;p&gt;curl -o foo.pdf ‘http://server1.cyberciti.biz/foo.pdf’&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section&quot;&gt;示例：&lt;/h4&gt;
&lt;p&gt;从osetc.com服务器里下载test.rar文件：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;curl -o test.rar ‘http://www.osetc.com/test.rar。’&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;选项 “-o”会将输出写入到指定的文件test.rar里&lt;/p&gt;

&lt;h4 id=&quot;curlurl&quot;&gt;在使用curl的时候也可以指定多个url，如下面的例子：&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;curl -O http://server{1,2,3}.osetc.com/&lt;/p&gt;

  &lt;p&gt;curl -O http://server{1,2,3}.osetc.com/test.pdf&lt;/p&gt;

  &lt;p&gt;curl -O ftp://intranet.site.{us,uk,in}.google/reports/test[a-z].tar.gz&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sun, 28 Aug 2016 05:20:00 +0800</pubDate>
        <link>http://yhj167.github.io/2016/08/28/OSX%E5%91%BD%E4%BB%A4(%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD)/</link>
        <guid isPermaLink="true">http://yhj167.github.io/2016/08/28/OSX%E5%91%BD%E4%BB%A4(%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD)/</guid>
        
        <category>操作系统</category>
        
        <category>OSX</category>
        
        <category>常用命令</category>
        
        
      </item>
    
      <item>
        <title>[搭建博客]Markdown语法说明</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;段落、标题、区块代码&lt;/h3&gt;

&lt;p&gt;一个段落是由一个以上的连接的行句组成，而一个以上的空行则会划分出不同的段落（空行的定义是显示上看起来像是空行，就被视为空行，例如有一行只有空白和 tab，那该行也会被视为空行），一般的段落不需要用空白或换行缩进。&lt;/p&gt;

&lt;p&gt;Markdown 支持两种标题的语法，Setext 和 atx 形式。Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），Atx 形式在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶。&lt;/p&gt;

&lt;p&gt;区块引用则使用 email 形式的 ‘&amp;gt;’ 角括号。&lt;/p&gt;

&lt;p&gt;Markdown 语法:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
A First Level Header
====================
A Second Level Header
---------------------

Now is the time for all good men to come to
the aid of their country. This is just a
regular paragraph.

The quick brown fox jumped over the lazy
dog's back.
### Header 3

&amp;gt; This is a blockquote.
&amp;gt; 
&amp;gt; This is the second paragraph in the blockquote.
&amp;gt;
&amp;gt; ## This is an H2 in a blockquote
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出 HTML 为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
&lt;h1&gt;A First Level Header&lt;/h1&gt;
&lt;h2&gt;A Second Level Header&lt;/h2&gt;
&lt;p&gt;Now is the time for all good men to come to
the aid of their country. This is just a
regular paragraph.&lt;/p&gt;
&lt;p&gt;The quick brown fox jumped over the lazy
dog's back.&lt;/p&gt;
&lt;h3&gt;Header 3&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a blockquote.&lt;/p&gt;
&lt;p&gt;This is the second paragraph in the blockquote.&lt;/p&gt;
&lt;h2&gt;This is an H2 in a blockquote&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-1&quot;&gt;修辞和强调&lt;/h4&gt;

&lt;p&gt;Markdown 使用星号和底线来标记需要强调的区段。&lt;/p&gt;

&lt;p&gt;Markdown 语法:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Some of these words *are emphasized*.
Some of these words _are emphasized also_.
Use two asterisks for **strong emphasis**.
Or, if you prefer, __use two underscores instead__.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出 HTML 为:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
&lt;p&gt;Some of these words &lt;em&gt;are emphasized&lt;/em&gt;.
Some of these words &lt;em&gt;are emphasized also&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Use two asterisks for &lt;strong&gt;strong emphasis&lt;/strong&gt;.
Or, if you prefer, &lt;strong&gt;use two underscores instead&lt;/strong&gt;.&lt;/p&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;列表&lt;/h3&gt;

&lt;p&gt;无序列表使用星号、加号和减号来做为列表的项目标记，这些符号是都可以使用的，使用星号：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
* Candy.
* Gum.
* Booze.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加号：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
+ Candy.
+ Gum.
+ Booze.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和减号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
- Candy.
- Gum.
- Booze.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;都会输出 HTML 为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
&lt;ul&gt;
&lt;li&gt;Candy.&lt;/li&gt;
&lt;li&gt;Gum.&lt;/li&gt;
&lt;li&gt;Booze.&lt;/li&gt;
&lt;/ul&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有序的列表则是使用一般的数字接着一个英文句点作为项目标记：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
1. Red
2. Green
3. Blue
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出 HTML 为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
&lt;ol&gt;
&lt;li&gt;Red&lt;/li&gt;
&lt;li&gt;Green&lt;/li&gt;
&lt;li&gt;Blue&lt;/li&gt;
&lt;/ol&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你在项目之间插入空行，那项目的内容会用 &amp;lt;p&amp;gt; 包起来，你也可以在一个项目内放上多个段落，只要在它前面缩排 4 个空白或 1 个 tab 。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
* A list item.

    With multiple paragraphs.

* Another item in the list.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出 HTML 为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A list item.&lt;/p&gt;
&lt;p&gt;With multiple paragraphs.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Another item in the list.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-3&quot;&gt;链接&lt;/h4&gt;

&lt;p&gt;Markdown 支援两种形式的链接语法： 行内 和 参考 两种形式，两种都是使用角括号来把文字转成连结。&lt;/p&gt;

&lt;p&gt;行内形式是直接在后面用括号直接接上链接：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
This is an [example link](http://example.com/).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出 HTML 为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
&lt;p&gt;This is an &lt;a href=&quot;http://example.com/&quot;&gt;
example link&lt;/a&gt;.&lt;/p&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你也可以选择性的加上 title 属性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
This is an [example link](http://example.com/ &quot;With a Title&quot;).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出 HTML 为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
&lt;p&gt;This is an &lt;a href=&quot;http://example.com/&quot; title=&quot;With a Title&quot;&gt;
example link&lt;/a&gt;.&lt;/p&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考形式的链接让你可以为链接定一个名称，之后你可以在文件的其他地方定义该链接的内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
I get 10 times more traffic from [Google][1] than from
[Yahoo][2] or [MSN][3].

[1]: http://google.com/ &quot;Google&quot;
[2]: http://search.yahoo.com/ &quot;Yahoo Search&quot;
[3]: http://search.msn.com/ &quot;MSN Search&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出 HTML 为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
&lt;p&gt;I get 10 times more traffic from &lt;a href=&quot;http://google.com/&quot; title=&quot;Google&quot;&gt;Google&lt;/a&gt; than from &lt;a href=&quot;http://search.yahoo.com/&quot; title=&quot;Yahoo Search&quot;&gt;Yahoo&lt;/a&gt; or &lt;a href=&quot;http://search.msn.com/&quot; title=&quot;MSN Search&quot;&gt;MSN&lt;/a&gt;.&lt;/p&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;title 属性是选择性的，链接名称可以用字母、数字和空格，但是不分大小写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
I start my morning with a cup of coffee and
[The New York Times][NY Times].

[ny times]: http://www.nytimes.com/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出 HTML 为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
&lt;p&gt;I start my morning with a cup of coffee and
&lt;a href=&quot;http://www.nytimes.com/&quot;&gt;The New York Times&lt;/a&gt;.&lt;/p&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-4&quot;&gt;图片&lt;/h4&gt;

&lt;p&gt;图片的语法和链接很像。&lt;/p&gt;

&lt;p&gt;行内形式（title 是选择性的）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
![alt text](/path/to/img.jpg &quot;Title&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考形式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
![alt text][id]

[id]: /path/to/img.jpg &quot;Title&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面两种方法都会输出 HTML 为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
&lt;img src=&quot;/path/to/img.jpg&quot; alt=&quot;alt text&quot; title=&quot;Title&quot; /&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-5&quot;&gt;代码&lt;/h4&gt;

&lt;p&gt;在一般的段落文字中，你可以使用反引号 ` 来标记代码区段，区段内的 &amp;amp;、&amp;lt; 和 &amp;gt; 都会被自动的转换成 HTML 实体，这项特性让你可以很容易的在代码区段内插入 HTML 码：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;I strongly recommend against using any &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt;

  &lt;p&gt;I wish SmartyPants used named entities like &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;mdash;&lt;/code&gt; instead of decimal-encoded entites like &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;#8212;&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果要建立一个已经格式化好的代码区块，只要每行都缩进 4 个空格或是一个 tab 就可以了，而 &amp;amp;、&amp;lt; 和 &amp;gt; 也一样会自动转成 HTML 实体。&lt;/p&gt;

&lt;p&gt;Markdown 语法:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If you want your page to validate under XHTML 1.0 Strict, you’ve got to put paragraph tags in your blockquotes:&lt;/p&gt;

  &lt;blockquote&gt;
&lt;p&gt;For example.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Thu, 11 Aug 2016 05:10:00 +0800</pubDate>
        <link>http://yhj167.github.io/2016/08/11/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-Markdown%E8%AF%AD%E6%B3%95%E8%AF%B4%E6%98%8E/</link>
        <guid isPermaLink="true">http://yhj167.github.io/2016/08/11/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-Markdown%E8%AF%AD%E6%B3%95%E8%AF%B4%E6%98%8E/</guid>
        
        <category>搭建博客</category>
        
        <category>Markdown</category>
        
        
      </item>
    
      <item>
        <title>[搭建博客]在github上用jekyll搭建博客</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;Yinhj 的 Blog 就这麽开通了。
&lt;a href=&quot;#jump&quot;&gt;跳过前言&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2016年，Yinhj总算有个地方可以写点自己的东西了。&lt;/p&gt;

&lt;p&gt;以前不喜欢在大众博客网站上写东西，一是感觉不好用，二是我们单位上不了外网-_-!!!。总之写点东西非常麻烦，导致实践中没有很好地形成总结，这样对长期的自身发展来说不好，实践中的一些思考过一阵又忘了，缺少积累。&lt;/p&gt;

&lt;p&gt;于是周末花了两天时间，在github上建了自己的博客，但是要写一个漂亮的博客还需要漂亮的模板，看上了基于jekyll和hexo实现的两种模板，前者基于ruby实现，后者基于node.js实现。个人还是喜欢jekyll，&lt;a href=&quot;http://jekyllthemes.org&quot;&gt;jekyllthemes&lt;/a&gt;上供下载的模板很多，&lt;a href=&quot;https://www.zhihu.com/question/20223939&quot;&gt;知乎&lt;/a&gt;上分享的模板也很多。编辑博客用markdown脚本来写(&lt;a href=&quot;http://wowubuntu.com/markdown/#list&quot;&gt;详细教程&lt;/a&gt;)，编辑器有很多，我比较喜欢&lt;a href=&quot;http://typora.io&quot;&gt;Typora&lt;/a&gt;，即写即现。主要的时间还是花在模板移植上了，环境安装和修改，第一次还是花了不少时间！&lt;/p&gt;

&lt;p id=&quot;jump&quot;&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;参考资料&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/u014015972/article/details/50497254&quot;&gt;用github + Jekyll写博客&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/07064eb79740&quot;&gt;Mac下Jekyll安装&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.ituring.com.cn/article/114888&quot;&gt;Jekyll+多说，建立属于你的轻博客&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 28 Jul 2016 04:20:00 +0800</pubDate>
        <link>http://yhj167.github.io/2016/07/28/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-%E5%9C%A8github%E4%B8%8A%E7%94%A8jekyll%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</link>
        <guid isPermaLink="true">http://yhj167.github.io/2016/07/28/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-%E5%9C%A8github%E4%B8%8A%E7%94%A8jekyll%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</guid>
        
        <category>搭建博客</category>
        
        <category>jekyll</category>
        
        
      </item>
    
  </channel>
</rss>
